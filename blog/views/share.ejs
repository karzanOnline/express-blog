<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>月度总结</title>
    <style>
        body{font-family: Helvetica Neue,Helvetica,Arial,PingFang SC,Hiragino Sans GB,WenQuanYi Micro Hei,Microsoft Yahei,sans-serif}
        .fmt{max-width:800px; margin: 0 auto; padding: 20px 0 40px 0; font-size: 1.4rem}
        hr{border-style:none; border-bottom: 1px solid #eee}
        .my-name{float: right; font-size: 23px; margin-top: 48px; font-weight: 300}
        h1{font-weight: 500}
    </style>
</head>
<body>

<div class="fmt" id="wmd-preview"><h1>月度总结 <div class="my-name">by caozheng</div></h1><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转眼间我已经来到金柚网近两个月了，对公司的业务和前后端架构也有所了解。我想每月都应该有这么一次总结，总结自己，总结他人，总结你所认知的一切。不仅是提高了自己，也是给公司一个能够相互了解的机会。好了，感情就抒发到这儿吧。先来谈谈我的总结。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;来到金柚后先对整体(前后端)的开发环境和开发方式做了一个大致的了解。对公司的业务和工作流程也做了深入的研究。对公司的大的发展方向十分看好。同时也不断的激励着员工进步。  <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;来到公司的通过开发到款确认、到款详情、社保专员请款详情、业务方审批、财务房审批、信息录入等cms后台功能性模块。从中发现了很多问题的存在：</p><h3>新老页面交替</h3><hr/><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如到款详情看源码一眼就能看出这不是一个内行人写的(后端人员用类velocity语法在模板引擎上渲染的)，虽然在页面中没有什么太大的问题，但是对服务器的压力增加了不少，而且对html了解的不深的话对SEO优化很难做。这种页面我的建议是能重构的尽量重构，当然在时间允许的基础上。</p><h3>开发方式</h3><hr/><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的问题我认为是比较严重的，严重的影响了开发人员的效率（这里前端的开发效率影响的是最严重的）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先从前端来看web开发工程化小有实践(webpack+gulp)，但功能局限只能在本地完成开发还可以，如果测试或者线上出现bug这时的处理方案是测试同步线上数据到开发，前端通过跑本地的代码取开发的数据测试bug。这种改bug的方式十分的局限其实完全可以前端使用代理来做到本地和(线上/测试)的数据联调。  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;许多小的问题也不再赘述对开发方式没有太大的影响。但是使用插件过多(太依赖开源的插件)导致前端必须加载的静态资源十分庞大。</p><ul><li><p>需要前端减少库的引用尽量手写代码</p></li><li><p>前端压缩代码(这里后端应该使用了gzip)</p></li><li><p>大部分没有使用css spirit来优化静态资源(可以将多个小图片合成到一个图片中减少http请求)<br>.....(很多优化方式)</p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于前端目前的情况来说应该所有的优化方案都没有使用除了压缩代码以外。对于前端的代码也是可以放到Jenkins里的，但是目前运营给出的方案也可以使用但是和jenkins比灵活性降低了太多。  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于后端的开发方式，使用的是PHP+JAVA，开发的模式对前端影响很大。目前公司前端的开发方式是在:</p><ul><li><p>本地开启服务跑静态资源</p></li><li><p>开启java的服务</p></li><li><p>如果涉及到php需要开启php的服务</p></li><li><p>如果想要自己本地测试数据这又要开启一个node服务。</p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种开发方式是在是太糟糕了。一个理想的开发方式是前端的只关心页面即静态资源，后端只关心业务逻辑。现在就是因为前后端没有完全的分离导致的。我建议前端使用框架模块化开发Angular、React、Vue 实现前后分离。</p><h3>协议规范</h3><hr/><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个良好的协议可以使前后端的交流更加融洽。我建议统一使用一个模板即规范文档如淘宝使用的规范</p><div class="widget-codetool" style="display:none;">
        <div class="widget-codetool--inner">
            <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
            <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="{    resultMap : {/*业务数据*/}
     success : [boolean], //true、false
     description : '错误信息'
     errCode: 'J000000' //成功
}" title="" data-original-title="复制"></span>
            <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
        </div>
    </div><pre class="hljs java"><code>{    resultMap : {<span class="hljs-comment">/*业务数据*/</span>}
     success : [<span class="hljs-keyword">boolean</span>], <span class="hljs-comment">//true、false</span>
     description : <span class="hljs-string">'错误信息'</span>
     errCode: <span class="hljs-string">'J000000'</span> <span class="hljs-comment">//成功</span>
}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更重要的是前端需要明确的了解每一个协议对应每一个字段的含义！如果后端返回数据量很大的话基本上一半的bug是对字段的理解错误。一个明确的规范对开发、测试和沟通都有很好的效果，磨刀不误砍柴工。</p><h3>调试</h3><hr/><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后端开发时期的调试应该是在本机完成的，不应该依赖于通过前端开启服务在打断点来调试，对前端的开发效率也有着不小的影响。</p><h3>关于产品</h3><hr/><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先一个好的产品必须熟练的掌握它的开发工具如:Axure RP。一个好的原型可以提高开发人员的开发效率，相信我真的可以提高很多！前端更注重的是页面的展示即页面的效果，设计是怎样的，一个按钮的功能是怎样的，链接点击后跳转的页面是怎么样的...很多细节的设计也是需要原型图来告知的。</p><ul><li><p>可以减少前后端和产品的沟通成本</p></li><li><p>可以大大提升开发人员的开发效率</p></li><li><p>对产品经理本身也是一个提升。</p></li><li><p>不能依赖于word的文档，word文档更大的用处是用来对大量数据的说明，主次关系需要理清。</p></li><li><p style="background-color: transparent;">产品经理要有长远的设计目标、思想(开发<span class="diff"></span>人员可以写更多的兼容代码，避免二次开发)</p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上是我近两个月对公司内部开发方式和业务的不成熟的总结，有什么不对的地方还希望指出。更推荐大家去自主的学习。要有极客精神，成为大牛的必经之路是需要对自己所做的东西、开发环境、性能有极致的追求。</p></div>

<div id="testID"></div>
<script>
        (function () {

//            function  CreateXmlHttp() {
//                console.log('constructor');
//                if(window.XMLHttpRequest){
//                    //是否可以使用
//                    this.xmlHttp = new XMLHttpRequest();
//                }
//
//                if(window.ActiveXObject){
//                    var _this = this;
//                    try {
//                        _this.xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");
//                    }catch (e){
//                        try {
//                            _this.xmlhttp = new ActiveXObject("msxml2.XMLHTTP");
//                        }catch (err){
//
//                        }
//                    }
//                }
//            }
//            function MyXml(url) {
//
//                CreateXmlHttp.call(this);
//
//                if (!this.xmlHttp) {
//                    alert("创建xmlhttp对象异常！");
//                    return false;
//                }
//
//                this.xmlHttp.open("POST", url, false);
//
//                this.xmlHttp.onreadystatechange = function () {
//                    if (this.xmlHttp.readyState == 4) {
//                        document.querySelector("#testID").innerHTML = "数据正在加载...";
//                        if (this.xmlHttp.status == 200) {
//                            document.write(this.xmlHttp.responseText);
//                        }
//                    }
//                }.bind(this)
//                this.xmlHttp.send();
//            }
//
//            MyXml.prototype = Object.create(CreateXmlHttp.prototype);
//
//            new MyXml('/test/render');




            var KLocation = function ( url ) {

                return new KLocation.fn.init( url );
            };

            KLocation.fn = KLocation.prototype = {

                constructor : KLocation,

                checkErr : function () {
                    if(!this.url){
                        throw ('error for param from getParam');
                    }
                    return true
                },

                protocolIndex : function (boolean) {

                    var re = new RegExp("[\:]","ig");
                    var urlTest = re.exec(this.url);

                    if(boolean){
                        //只是检测是否有协议类型
                        if(!urlTest){
                            return 0
                        }
                    }
                    if(!urlTest){
                        throw ('Protocol is not find, check your code')
                    }
                    var index = urlTest.index;
                    return index+1
                }

            };
            init = KLocation.fn.init = function () {

                if(!arguments.length){
                    throw ('error for param from KL constructor')
                }

                this.url = arguments[0];
                this.protocol = this.getProtocol();
                this.host = this.getHost();

            }
            init.prototype = KLocation.fn;

            //返回json
            //url后面的参数json化
            init.prototype.getParam = function () {
                KLocation.fn.checkErr.call(this)

                var re = new RegExp("([?=&])([A-Za-z0-9]*)","ig"),
                    rel = new RegExp("[\"\']","ig");
                    arr = [],
                    result = {},
                    url = this.url.replace(rel,""); //去除" ' 的影响

                //to array
                while(value=re.exec(url)){

                    if(value[2]==''){
                        continue;
                    }

                    arr.push(value[2]);
                }

                //to json
                for (var i=0;i<arr.length;i++){
                    if(i%2==0){
                        //even property
                        result[arr[i]] = ''

                    }else{
                        //odd value
                        result[arr[i-1]] = arr[i]
                    }
                }

                return result
            }

            //返回string
            //protocol
            init.prototype.getProtocol = function () {
                //日常判断url是否存在
                KLocation.fn.checkErr.call(this);

                return this.url.slice(0, KLocation.fn.protocolIndex.call(this,false))
            }

            init.prototype.getHost = function () {

                KLocation.fn.checkErr.call(this);
                var re = new RegExp("(\.)","ig")
                var index = KLocation.fn.protocolIndex.call(this,true);
                var i = 0;
                re.exec(this.url);
                debugger;
                var last =  re.exec(this.url).index;

                //检查如果http:// 写成http:/ 时只需将/全局匹配掉
                var host =  this.url.slice(index, last).replace(/[/]/ig,'');
                return host
            }


            console.log(KLocation('http://www.baidu.com?"a"="1"&b=2'));

//            console.log(KLocation.fn)

        })()
    </script>
</body>
</html>